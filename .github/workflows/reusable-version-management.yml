name: Reusable Version Management

on:
  workflow_call:
    inputs:
      platform:
        description: 'Platform identifier'
        required: true
        type: string
      version-hash:
        description: 'Version hash to store'
        required: true
        type: string
      release-name:
        description: 'Release name to check'
        required: true
        type: string
      force-build:
        description: 'Force build regardless of version changes'
        required: false
        type: boolean
        default: false
    outputs:
      should_build:
        value: ${{ jobs.manage-version.outputs.should_build }}
      new_hash:
        value: ${{ jobs.manage-version.outputs.new_hash }}
      new_hash_full:
        value: ${{ jobs.manage-version.outputs.new_hash_full }}
      new_version:
        value: ${{ jobs.manage-version.outputs.new_version }}
      build_reason:
        value: ${{ jobs.manage-version.outputs.build_reason }}

jobs:
  manage-version:
    name: Manage Version for ${{ inputs.platform }}
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.compare.outputs.should_build }}
      new_hash: ${{ steps.version.outputs.hash }}
      new_hash_full: ${{ steps.version.outputs.hash_full }}
      new_version: ${{ steps.version.outputs.version }}
      build_reason: ${{ steps.compare.outputs.build_reason }}
    steps:
      - name: Checkout this repo
        uses: actions/checkout@v4

      - name: Get upstream commit hash
        id: upstream
        run: |
          REPO_URL="https://git.citron-emu.org/Citron/Emulator.git"
          FULL_HASH=$(git ls-remote "$REPO_URL" HEAD | cut -f1)
          SHORT_HASH=$(echo "$FULL_HASH" | cut -c1-8)
          echo "hash_short=$SHORT_HASH" >> "$GITHUB_OUTPUT"
          echo "hash_full=$FULL_HASH" >> "$GITHUB_OUTPUT"

      - name: Get latest version
        id: version
        run: |
          git clone --depth 1 https://git.citron-emu.org/Citron/Emulator.git temp_repo
          cd temp_repo
          git fetch --tags --depth 100
          LATEST_TAG=$(git describe --tags --abbrev=0)
          VERSION=${LATEST_TAG#v}
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "hash=$SHORT_HASH" >> "$GITHUB_OUTPUT"
          echo "hash_full=$FULL_HASH" >> "$GITHUB_OUTPUT"

      - name: Get last built version for platform
        id: last_built
        run: |
          # Read from single version file
          LAST_HASH=$(grep "^${{ inputs.platform }}:" LATEST_VERSIONS 2>/dev/null | cut -d: -f2 | tr -d '\n' || echo "none")
          echo "last_hash=$LAST_HASH" >> "$GITHUB_OUTPUT"

      - name: Check if release exists
        id: release_check
        run: |
          if gh release view ${{ inputs.release-name }} --repo "${{ github.repository }}" > /dev/null 2>&1; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

      - name: Compare versions
        id: compare
        run: |
          FORCE_BUILD="${{ inputs.force-build }}"
          if [ "$FORCE_BUILD" = "true" ]; then
            echo "should_build=true" >> "$GITHUB_OUTPUT"
            echo "build_reason=forced_build" >> "$GITHUB_OUTPUT"
            echo "✅ Build forced by workflow input"
          elif [ "${{ steps.upstream.outputs.hash_short }}" != "${{ steps.last_built.outputs.last_hash }}" ]; then
            echo "should_build=true" >> "$GITHUB_OUTPUT"
            echo "build_reason=new_commit" >> "$GITHUB_OUTPUT"
            echo "✅ New commit detected - will build"
          elif [ "${{ steps.release_check.outputs.exists }}" != "true" ]; then
            echo "should_build=true" >> "$GITHUB_OUTPUT"
            echo "build_reason=missing_release" >> "$GITHUB_OUTPUT"
            echo "✅ No release exists - will build"
          else
            echo "should_build=false" >> "$GITHUB_OUTPUT"
            echo "build_reason=no_changes" >> "$GITHUB_OUTPUT"
            echo "⏭️ No changes - skipping build"
          fi

      - name: Update version file
        if: always() && github.ref_name == 'main'
        run: |
          # Create or update single version file with platform-specific entries
          if [ -f LATEST_VERSIONS ]; then
            # Remove existing entry for this platform
            grep -v "^${{ inputs.platform }}:" LATEST_VERSIONS > LATEST_VERSIONS.tmp || true
            mv LATEST_VERSIONS.tmp LATEST_VERSIONS
          fi
          
          # Add new entry
          echo "${{ inputs.platform }}:${{ inputs.version-hash }}" >> LATEST_VERSIONS
          
          # Commit and push
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add LATEST_VERSIONS
          git commit -m "Update LATEST_VERSIONS for ${{ inputs.platform }} to ${{ inputs.version-hash }} [skip ci]" || exit 0
          for i in {1..5}; do
            git pull --rebase origin main && git push && break || sleep 2
          done